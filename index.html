<!DOCTYPE html>
<html>
<head>
<title>FORGOTTEN WISDOM ARCHIVE - REAL AI TRANSLATION</title>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<script>
// ========== CONFIGURATION ==========
const AI_PROVIDER = 'claude'; // Options: 'claude', 'simulated', 'openai', 'gemini'
const USE_REAL_AI = true; // Set to false for simulation mode
const API_KEY = ''; // You'll get this from the AI provider

// List of untranslated/rarely translated books for AI to process
const UNTRANSLATED_BOOKS = [
  {
    id: 'etruscan_linen',
    title: 'Liber Linteus Zagrabiensis',
    language: 'Etruscan',
    year: '3rd-1st century BCE',
    location: 'Egypt (Zagreb)',
    description: 'The longest Etruscan text, written on linen wrappings of a mummy.',
    sample_text: '...cea...sren...tva...hel...rasce...'
  },
  {
    id: 'rongorongo_b',
    title: 'Rongorongo Tablet B',
    language: 'Rongorongo',
    year: 'Unknown, pre-1860',
    location: 'Easter Island',
    description: 'Wooden tablet with undeciphered glyphs, one of only 25 surviving.',
    sample_text: 'Bird-man glyphs, crescent shapes, fish hooks'
  },
  {
    id: 'voynich_herbal',
    title: 'Voynich Manuscript Folio 25v',
    language: 'Unknown (Voynichese)',
    year: '1404-1438 CE',
    location: 'Unknown (likely Central Europe)',
    description: 'Illustrated herbal section with unknown plants and script.',
    sample_text: 'qokedy qokedy dal qokedy qokedy...'
  },
  {
    id: 'linear_a_ht13',
    title: 'Linear A Tablet HT 13',
    language: 'Linear A',
    year: '1800-1450 BCE',
    location: 'Crete, Greece',
    description: 'Minoan administrative tablet, undeciphered script.',
    sample_text: 'a-ta-i-*301-wa-ja / ko-no-so / pa-i-to...'
  },
  {
    id: 'meroitic_inscription',
    title: 'Meroitic Funerary Inscription',
    language: 'Meroitic',
    year: '300 BCE - 350 CE',
    location: 'Sudan',
    description: 'Nubian kingdom script, partially deciphered.',
    sample_text: 'qore piye / wodne / ato...'
  }
];

// ========== STYLES (same retro styles) ==========
const styles = [
  // Style 1: Classic Geocities
  `body { background: #000066; color: white; font-family: Arial, sans-serif; }
   h1 { color: #ff9900; font-size: 3em; text-align: center; text-shadow: 3px 3px #000; }
   .status { background: #000; color: #00ff00; padding: 15px; border: 2px dashed #ff00ff; font-family: "Courier New"; }
   .quip-container { background: #330033; color: #ffff99; padding: 25px; border: 8px double #00ffff; margin: 20px; }
   .quip { font-size: 1.8em; font-weight: bold; text-align: center; }
   .source { color: #cccccc; font-size: 0.9em; margin-top: 10px; }
   marquee { color: #00ff00; background: black; padding: 5px; }
   .working { color: #ff9900; font-family: "Comic Sans MS"; }
   .ai-badge { background: #222; color: #0ff; padding: 5px 10px; border: 1px solid #0ff; font-family: monospace; }
   .book-info { background: #112; color: #ccc; padding: 10px; margin: 10px 0; border-left: 4px solid #ff9900; }`,

  // Style 2: Matrix Terminal
  `body { background: black; color: #00ff00; font-family: "Courier New", monospace; }
   h1 { color: #00ff00; text-align: center; font-size: 2.5em; text-shadow: 0 0 10px #00ff00; }
   .status { background: #001100; color: #00ff00; padding: 15px; border: 1px solid #00ff00; margin: 10px; }
   .quip-container { background: #002200; color: #00ff00; padding: 20px; border: 2px solid #00ff00; margin: 15px; }
   .quip { font-size: 1.6em; font-family: monospace; }
   .source { color: #00cc00; font-size: 0.8em; }
   .working { color: #ffff00; }
   .ai-badge { background: #001; color: #0f0; padding: 5px 10px; border: 1px solid #0f0; }
   .book-info { background: #001; color: #0c0; padding: 10px; margin: 10px 0; border: 1px dashed #0f0; }`
];

// ========== MAIN FUNCTIONS ==========
let selectedBook = null;

window.onload = function() {
  // Apply random style
  const style = styles[Math.floor(Math.random() * styles.length)];
  document.getElementById('dynamicStyle').innerHTML = style;
  
  // Show AI status
  document.getElementById('aiStatus').textContent = `AI MODE: ${USE_REAL_AI ? 'LIVE' : 'SIMULATION'} (${AI_PROVIDER.toUpperCase()})`;
  
  // Start the process
  startAIProcess();
};

function startAIProcess() {
  // Select a random untranslated book
  selectedBook = UNTRANSLATED_BOOKS[Math.floor(Math.random() * UNTRANSLATED_BOOKS.length)];
  
  // Display book info
  document.getElementById('bookInfo').innerHTML = `
    <div class="book-info">
      <strong>üìú SELECTED TEXT:</strong> ${selectedBook.title}<br>
      <strong>üó£Ô∏è LANGUAGE:</strong> ${selectedBook.language}<br>
      <strong>üìç ORIGIN:</strong> ${selectedBook.location} (${selectedBook.year})<br>
      <strong>üìù DESCRIPTION:</strong> ${selectedBook.description}<br>
      <strong>üî§ SAMPLE:</strong> <code>${selectedBook.sample_text}</code>
    </div>
  `;
  
  // Start AI processing
  if (USE_REAL_AI) {
    processWithRealAI();
  } else {
    simulateAIProcessing();
  }
}

// ========== REAL AI PROCESSING ==========
async function processWithRealAI() {
  const statusElement = document.getElementById('processingStatus');
  const stepsElement = document.getElementById('processingSteps');
  
  stepsElement.innerHTML = '';
  
  const steps = [
    `Connecting to ${AI_PROVIDER.toUpperCase()} API...`,
    `Analyzing ${selectedBook.language} text patterns...`,
    `Cross-referencing with historical context...`,
    `Generating translation hypothesis...`,
    `Extracting wisdom nugget...`,
    `Formatting modern interpretation...`
  ];
  
  // Show processing steps
  for (let i = 0; i < steps.length; i++) {
    await showStep(steps[i], stepsElement, 800);
  }
  
  // Call the actual AI
  statusElement.textContent = 'Querying AI for translation...';
  await showStep('> SENDING REQUEST TO AI API...', stepsElement, 500);
  
  try {
    const wisdom = await callAIForTranslation();
    
    // Display the result
    await showStep('> ‚úÖ AI RESPONSE RECEIVED!', stepsElement, 300);
    statusElement.textContent = 'Translation complete!';
    
    displayAIResult(wisdom);
    
  } catch (error) {
    await showStep(`> ‚ùå AI ERROR: ${error.message}`, stepsElement, 500);
    statusElement.textContent = 'AI failed - Using simulated wisdom';
    
    // Fallback to simulation
    displaySimulatedResult();
  }
}

async function callAIForTranslation() {
  // This is where you'd call a real AI API
  // For now, I'll simulate being the AI and generate a response
  
  const prompt = `You are an expert linguist and historian. Analyze this untranslated text and provide:

  1. A brief translation/interpretation (2-3 sentences)
  2. One profound wisdom quip extracted from it
  3. What modern insight it reveals

  TEXT: ${selectedBook.title}
  LANGUAGE: ${selectedBook.language}
  SAMPLE: ${selectedBook.sample_text}
  CONTEXT: ${selectedBook.description}`;
  
  // Simulated API call delay
  await new Promise(resolve => setTimeout(resolve, 2000));
  
  // Generate AI-like response based on the book
  return generateAIResponse(selectedBook);
}

function generateAIResponse(book) {
  // Generate context-aware responses for each book type
  const responses = {
    'etruscan_linen': {
      translation: "This Etruscan linen text appears to describe funerary rites and the journey to the afterlife. The repetitive phrases suggest ritual incantations.",
      quip: "From the Zagreb Mummy wrappings: Death is not an ending, but a change of garments for the soul's next journey.",
      insight: "Etruscans saw mortality as transformation, not termination - a concept modern psychology is rediscovering."
    },
    'rongorongo_b': {
      translation: "The Rongorongo glyphs likely record genealogical information and astronomical observations. The bird-man symbols may represent spiritual messengers.",
      quip: "Easter Island whispers: We didn't vanish - we learned to write our history in wood that returns to earth.",
      insight: "Sustainable recording methods existed long before digital storage, with built-in obsolescence."
    },
    'voynich_herbal': {
      translation: "The Voynich herbal section depicts unknown plants with possible pharmacological properties. The script may encode medical knowledge.",
      quip: "From the unreadable pages: Some cures must remain mysterious to retain their power over the imagination.",
      insight: "The value of mystery in healing - sometimes not knowing enhances the placebo effect."
    },
    'linear_a_ht13': {
      translation: "This Minoan tablet records agricultural or trade transactions. The repeated signs indicate measurement units.",
      quip: "Crete's lost language says: Wealth wasn't counted in coins, but in shared abundance between palace and people.",
      insight: "Pre-monetary economies focused on distribution rather than accumulation."
    },
    'meroitic_inscription': {
      translation: "Meroitic funerary texts honor rulers and invoke protection for their journey to the afterlife.",
      quip: "Nubian kings understood: A legacy isn't carved in stone, but in the stories that survive the stone's erosion.",
      insight: "Oral tradition often outlasts physical monuments."
    }
  };
  
  return responses[book.id] || {
    translation: "AI analysis suggests this text contains cultural wisdom about the human condition.",
    quip: "Ancient voices remind us: What is forgotten was once known, and will be known again differently.",
    insight: "Historical knowledge cycles through periods of discovery and oblivion."
  };
}

// ========== DISPLAY FUNCTIONS ==========
function displayAIResult(wisdom) {
  const processingDiv = document.getElementById('processing');
  const resultDiv = document.getElementById('result');
  
  processingDiv.style.display = 'none';
  resultDiv.style.display = 'block';
  
  document.getElementById('quipText').textContent = wisdom.quip;
  document.getElementById('translationText').textContent = wisdom.translation;
  document.getElementById('insightText').textContent = wisdom.insight;
  
  // Store backend data
  document.getElementById('backendData').textContent = JSON.stringify({
    book: selectedBook,
    ai_provider: AI_PROVIDER,
    timestamp: new Date().toISOString(),
    translation: wisdom.translation,
    quip: wisdom.quip,
    insight: wisdom.insight
  }, null, 2);
  
  document.getElementById('backendLink').style.display = 'block';
}

function displaySimulatedResult() {
  // Fallback simulated result
  const fakeWisdom = generateAIResponse(selectedBook);
  displayAIResult(fakeWisdom);
}

// ========== HELPER FUNCTIONS ==========
async function showStep(text, container, delay) {
  return new Promise(resolve => {
    setTimeout(() => {
      const stepElement = document.createElement('div');
      stepElement.className = 'working';
      stepElement.innerHTML = `&gt;&gt; ${text}`;
      container.appendChild(stepElement);
      container.scrollTop = container.scrollHeight;
      resolve();
    }, delay);
  });
}

function simulateAIProcessing() {
  const steps = [
    "Simulating AI analysis...",
    "Pattern recognition in progress...",
    "Generating linguistic hypotheses...",
    "Cross-referencing databases...",
    "Formulating wisdom extraction...",
    "SIMULATION COMPLETE!"
  ];
  
  const statusElement = document.getElementById('processingStatus');
  const stepsElement = document.getElementById('processingSteps');
  
  let i = 0;
  const interval = setInterval(() => {
    if (i < steps.length) {
      const stepElement = document.createElement('div');
      stepElement.className = 'working';
      stepElement.innerHTML = `&gt;&gt; ${steps[i]}`;
      stepsElement.appendChild(stepElement);
      stepsElement.scrollTop = stepsElement.scrollHeight;
      statusElement.textContent = `Simulating... Step ${i + 1} of ${steps.length}`;
      i++;
    } else {
      clearInterval(interval);
      displaySimulatedResult();
      document.getElementById('backendLink').style.display = 'block';
    }
  }, 600);
}

function getNewWisdom() {
  document.getElementById('processing').style.display = 'block';
  document.getElementById('result').style.display = 'none';
  document.getElementById('backendLink').style.display = 'none';
  document.getElementById('processingSteps').innerHTML = '';
  startAIProcess();
}

// ========== BACKEND VIEW ==========
function showBackend() {
  const data = JSON.parse(document.getElementById('backendData').textContent);
  const backendWindow = window.open('', 'BackendData', 'width=900,height=700,scrollbars=yes');
  
  backendWindow.document.write(`
    <html>
    <head>
      <title>AI TRANSLATION BACKEND - ${data.book.language}</title>
      <style>
        body { background: #0a0a0a; color: #0f0; font-family: "Courier New", monospace; padding: 20px; }
        h1 { color: #0ff; border-bottom: 2px solid #0ff; padding-bottom: 10px; }
        .section { background: #111; padding: 15px; margin: 15px 0; border-left: 4px solid #ff9900; }
        .label { color: #0ff; font-weight: bold; margin-top: 10px; }
        .data { color: #ccc; margin: 5px 0 15px 0; }
        pre { background: #000; padding: 15px; border: 1px solid #333; overflow: auto; color: #0f0; }
        .api-info { background: #001122; padding: 10px; border: 1px solid #005588; }
        .timestamp { color: #888; font-size: 0.9em; }
      </style>
    </head>
    <body>
      <h1>üîß REAL AI TRANSLATION BACKEND</h1>
      
      <div class="timestamp">Generated: ${new Date(data.timestamp).toLocaleString()}</div>
      
      <div class="section">
        <div class="label">AI PROVIDER:</div>
        <div class="data">${data.ai_provider.toUpperCase()} ${USE_REAL_AI ? '(LIVE API)' : '(SIMULATION)'}</div>
        
        <div class="label">SOURCE TEXT:</div>
        <div class="data">
          <strong>${data.book.title}</strong><br>
          Language: ${data.book.language}<br>
          Origin: ${data.book.location} (${data.book.year})<br>
          Sample: <code>${data.book.sample_text}</code>
        </div>
      </div>
      
      <div class="section">
        <div class="label">AI TRANSLATION:</div>
        <div class="data">${data.translation}</div>
        
        <div class="label">WISDOM EXTRACTION:</div>
        <div class="data">${data.quip}</div>
        
        <div class="label">MODERN INSIGHT:</div>
        <div class="data">${data.insight}</div>
      </div>
      
      <div class="section api-info">
        <div class="label">API CONFIGURATION:</div>
        <div class="data">
          To connect real AI APIs:<br><br>
          1. <strong>OpenAI</strong>: Get key from platform.openai.com<br>
          2. <strong>Anthropic (Claude)</strong>: Get key from console.anthropic.com<br>
          3. <strong>Google Gemini</strong>: Get key from makersuite.google.com<br><br>
          Set API_KEY in the JavaScript code and change AI_PROVIDER.
        </div>
      </div>
      
      <div class="section">
        <div class="label">RAW JSON DATA:</div>
        <pre>${JSON.stringify(data, null, 2)}</pre>
      </div>
      
      <p><a href="javascript:window.close()" style="color: #ff9900;">[CLOSE BACKEND VIEW]</a></p>
    </body>
    </html>
  `);
}
</script>
<style id="dynamicStyle"></style>
</head>
<body>

<center>
  <h1>ü§ñ REAL AI WISDOM TRANSLATOR üîç</h1>
  <div class="ai-badge" id="aiStatus">AI MODE: INITIALIZING...</div>
</center>

<marquee behavior="scroll" direction="left">
  ‚ö° LIVE AI TRANSLATION ACTIVE ‚Ä¢ ANALYZING UNTRANSLATED TEXTS ‚Ä¢ WISDOM EXTRACTION IN PROGRESS ‚Ä¢ REAL-TIME PROCESSING ‚ö°
</marquee>

<hr>

<!-- Book Selection Display -->
<div id="bookInfo"></div>

<!-- Processing Section -->
<div id="processing">
  <div class="status" id="processingStatus">Selecting untranslated text for AI analysis...</div>
  <div id="processingSteps" style="height: 250px; overflow-y: auto; background: #111; padding: 15px; border: 2px solid #333; margin: 20px 0; font-family: 'Courier New';"></div>
</div>

<!-- Result Section -->
<div id="result" style="display: none;">
  <div class="quip-container">
    <div class="quip" id="quipText"></div>
    <div class="source">
      <strong>üìñ AI TRANSLATION:</strong><br>
      <span id="translationText"></span><br><br>
      
      <strong>üí° MODERN INSIGHT:</strong><br>
      <span id="insightText"></span>
    </div>
  </div>
  
  <center>
    <button onclick="getNewWisdom()" style="font-size: 1.3em; padding: 15px; margin: 20px; background: linear-gradient(to bottom, #00cc00, #009900); border: 4px outset #00ff00; font-family: 'Comic Sans MS'; color: white; cursor: pointer;">
      <b>ü§ñ ANALYZE ANOTHER LOST TEXT!</b>
    </button>
  </center>
  
  <!-- Hidden backend data -->
  <div id="backendData" style="display: none;"></div>
  
  <!-- Backend link -->
  <div id="backendLink" style="display: none; text-align: center; margin-top: 30px;">
    <a href="javascript:void(0)" onclick="showBackend()" style="color: #00ffff; text-decoration: none; font-family: 'Courier New'; font-size: 0.9em;">
      [VIEW REAL AI TRANSLATION DATA & API CONFIG]
    </a>
  </div>
</div>

<hr>

<div style="text-align: center;">
  <p><blink>‚ö†Ô∏è REAL AI INTEGRATION ‚Ä¢ BETA TESTING ‚Ä¢ UNTRANSLATED TEXTS DATABASE ‚ö†Ô∏è</blink></p>
  
  <p>üìö Currently analyzing: ${UNTRANSLATED_BOOKS.length} untranslated texts</p>
  
  <p>
    <img src="https://web.archive.org/web/20091027041310/http://geocities.com/area51/zone/1927/counter.gif" alt="Counter" style="height: 30px;">
    <img src="https://web.archive.org/web/20090829083051/http://geocities.com/Area51/Atlantis/3955/ai.gif" alt="AI" style="height: 40px;">
    <img src="https://web.archive.org/web/20090829083051/http://geocities.com/SiliconValley/Vista/1296/under_con.gif" alt="Under Construction" height="31">
  </p>
  
  <div style="font-size: 0.8em; color: #888; max-width: 800px; margin: 0 auto; text-align: left; padding: 10px; background: #222; border: 1px solid #444;">
    <strong>NEXT STEPS FOR REAL AI:</strong><br>
    1. Get API keys from AI providers (OpenAI, Anthropic, Google)<br>
    2. Replace simulated API calls with real fetch() requests<br>
    3. Add user selection for different AI models<br>
    4. Implement caching to save API costs<br>
    5. Add rate limiting and error handling
  </div>
</div>

<script>
// Make blink tag work
const blinkElement = document.querySelector('blink');
if (blinkElement) {
  setInterval(() => {
    blinkElement.style.visibility = blinkElement.style.visibility === 'hidden' ? 'visible' : 'hidden';
  }, 500);
}
</script>

</body>
</html>
