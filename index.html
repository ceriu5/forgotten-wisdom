<!DOCTYPE html>
<html>
<head>
<title>Ancient Wisdom Oracle ‚Ä¢ AI Translation Engine</title>
<meta charset="UTF-8">
<style>
/* ===== 90s AESTHETIC ===== */
:root {
  --matrix-green: #00ff00;
  --cyber-blue: #00ffff;
  --retro-pink: #ff00ff;
  --amber: #ff9900;
  --deep-space: #000033;
  --terminal-bg: #0a0a0a;
}

body {
  background: var(--deep-space);
  color: #ccccff;
  font-family: 'Courier New', monospace;
  background-image: 
    url('data:image/svg+xml;utf8,<svg width="100" height="100" xmlns="http://www.w3.org/2000/svg"><rect width="100" height="100" fill="%23000022"/><path d="M0,0 L100,100" stroke="%23003366" stroke-width="1"/><path d="M100,0 L0,100" stroke="%23003366" stroke-width="1"/></svg>');
  margin: 0;
  padding: 20px;
}

/* ===== MAIN CONTAINERS ===== */
.main-container {
  max-width: 900px;
  margin: 0 auto;
  background: rgba(0, 0, 51, 0.9);
  border: 8px double var(--cyber-blue);
  padding: 20px;
  box-shadow: 0 0 30px rgba(0, 255, 255, 0.3);
}

.header {
  text-align: center;
  padding: 20px;
  border-bottom: 3px dashed var(--retro-pink);
  margin-bottom: 30px;
}

.header h1 {
  color: var(--matrix-green);
  font-size: 2.8em;
  margin: 0;
  text-shadow: 0 0 10px var(--matrix-green);
  letter-spacing: 2px;
}

.header .subtitle {
  color: var(--cyber-blue);
  font-size: 1.2em;
  margin-top: 10px;
}

/* ===== PUBLIC FRONT-END ===== */
.oracle-machine {
  background: var(--terminal-bg);
  border: 4px ridge var(--amber);
  padding: 25px;
  margin: 25px 0;
  position: relative;
}

.oracle-machine:before {
  content: "‚ö° AI TRANSLATION ENGINE ‚ö°";
  position: absolute;
  top: -12px;
  left: 20px;
  background: var(--terminal-bg);
  color: var(--matrix-green);
  padding: 0 10px;
  font-size: 0.9em;
}

.translation-display {
  min-height: 200px;
  padding: 20px;
  background: #001122;
  border: 2px solid #003366;
  margin: 20px 0;
}

.wisdom-quip {
  font-size: 1.6em;
  color: var(--amber);
  text-align: center;
  padding: 20px;
  background: #002200;
  border-left: 5px solid var(--matrix-green);
  margin: 20px 0;
  animation: glow 2s infinite alternate;
}

@keyframes glow {
  from { box-shadow: 0 0 5px var(--matrix-green); }
  to { box-shadow: 0 0 15px var(--matrix-green); }
}

.controls {
  text-align: center;
  margin: 30px 0;
}

.magic-button {
  background: linear-gradient(45deg, #ff00ff, #00ffff);
  border: 4px outset #00aaff;
  color: black;
  padding: 20px 40px;
  font-size: 1.4em;
  font-family: 'Courier New';
  font-weight: bold;
  cursor: pointer;
  text-shadow: 1px 1px 2px rgba(255,255,255,0.5);
}

.magic-button:hover {
  background: linear-gradient(45deg, #00ffff, #ff00ff);
  border-style: inset;
}

.magic-button:active {
  transform: translateY(2px);
}

/* ===== BETA PANEL (Collapsible) ===== */
.beta-panel {
  background: #111144;
  border: 3px solid var(--retro-pink);
  margin: 30px 0;
  padding: 0;
}

.beta-header {
  background: #330033;
  color: var(--retro-pink);
  padding: 15px;
  cursor: pointer;
  font-size: 1.2em;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.beta-content {
  padding: 20px;
  display: none;
}

.beta-method {
  background: #222255;
  padding: 15px;
  margin: 15px 0;
  border: 1px solid #444477;
}

.beta-button {
  background: #333366;
  color: white;
  border: 2px outset #555599;
  padding: 10px 20px;
  margin: 5px;
  cursor: pointer;
  font-family: 'Courier New';
}

.beta-button:hover {
  background: #444477;
}

/* ===== BACKEND VIEW ===== */
.backend-view {
  background: #000;
  color: var(--matrix-green);
  padding: 20px;
  margin: 20px 0;
  border: 2px solid var(--matrix-green);
  font-family: monospace;
  font-size: 0.9em;
  display: none;
  max-height: 400px;
  overflow-y: auto;
}

.backend-section {
  margin: 15px 0;
  padding: 10px;
  background: #001100;
  border: 1px solid #003300;
}

/* ===== STATUS INDICATORS ===== */
.status-indicator {
  display: inline-block;
  width: 12px;
  height: 12px;
  border-radius: 50%;
  margin-right: 8px;
}

.status-online {
  background: var(--matrix-green);
  box-shadow: 0 0 8px var(--matrix-green);
}

.status-offline {
  background: #ff3300;
}

.status-processing {
  background: var(--amber);
  animation: pulse 1s infinite;
}

@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.5; }
}

/* ===== 90s ELEMENTS ===== */
.visitor-counter {
  text-align: center;
  margin: 30px;
  padding: 15px;
  background: #000;
  border: 3px dotted var(--cyber-blue);
}

.construction {
  text-align: center;
  color: var(--amber);
  margin: 20px;
  padding: 10px;
  background: #332200;
  border: 2px dashed var(--amber);
}

.blink {
  animation: blink 1s infinite;
}

@keyframes blink {
  50% { opacity: 0; }
}

.marquee-container {
  background: black;
  padding: 8px;
  margin: 20px 0;
  border: 1px solid var(--matrix-green);
  overflow: hidden;
}

/* ===== UTILITY ===== */
.hidden {
  display: none;
}

.code-block {
  background: #001122;
  color: var(--matrix-green);
  padding: 15px;
  border: 1px solid #003366;
  font-family: monospace;
  overflow-x: auto;
  margin: 10px 0;
}

.source-material {
  background: #110011;
  padding: 15px;
  margin: 15px 0;
  border-left: 4px solid var(--retro-pink);
}

.footer {
  text-align: center;
  margin-top: 40px;
  padding-top: 20px;
  border-top: 2px solid #444477;
  color: #8888aa;
  font-size: 0.9em;
}
</style>
</head>
<body>

<div class="main-container">
  <!-- HEADER -->
  <div class="header">
    <h1>ìÅπ ANCIENT WISDOM ORACLE ìÇÄ</h1>
    <div class="subtitle">AI-Powered Translation of Lost Texts</div>
    <div style="margin-top: 10px;">
      <span class="status-indicator status-online"></span> AI Engine: <span id="aiStatus">Ready</span>
    </div>
  </div>

  <!-- PUBLIC FRONT-END (THE MAGIC) -->
  <div class="oracle-machine">
    <h2 style="color: var(--cyber-blue); text-align: center;">üîÆ TRANSLATION ORACLE</h2>
    
    <div class="translation-display" id="translationDisplay">
      <div style="text-align: center; color: #666; padding: 50px 20px;">
        <div style="font-size: 3em; margin-bottom: 20px;">ìÅπ</div>
        <div>The Oracle is silent. Initiate translation to reveal forgotten wisdom.</div>
      </div>
    </div>
    
    <div class="controls">
      <button class="magic-button" onclick="initiateTranslation()">
        üåÄ INITIATE TRANSLATION
      </button>

      <div id="queryToggle" style="cursor:pointer; color:#0f0; margin:20px 0; font-family:monospace; font-size:14px; text-align:center;">
  [üîç SEEK SPECIFIC WISDOM]
</div>

<div id="queryInput" style="display:none; margin:20px 0; text-align:center;">
  <input type="text" id="userQuery" placeholder="e.g. curiosity, love, Epic of Gilgamesh..." 
         style="background:#000; color:#0f0; border:2px solid #0f0; padding:10px; width:80%; max-width:400px; font-family:monospace; font-size:14px;">
  <br><br>
  <button onclick="initiateQueryTranslation()" 
          style="background:#0f0; color:#000; border:none; padding:12px 20px; font-family:monospace; font-size:14px; cursor:pointer;">
    CONSULT THE ANCIENTS
  </button>
</div>
      
      <div style="margin-top: 15px; color: #aaa; font-size: 0.9em;">
        <span class="status-indicator status-processing"></span> Processing ancient text...
      </div>
    </div>
    
    <div id="wisdomResult" class="hidden">
      <div class="wisdom-quip" id="wisdomText"></div>
      
      <div style="text-align: center; margin: 20px;">
        <button class="beta-button" onclick="toggleBackendView()">
          üîç VIEW TRANSLATION DATA
        </button>
        <button class="beta-button" onclick="initiateTranslation()">
          üîÑ TRANSLATE ANOTHER
        </button>
      </div>
    </div>
  </div>

  <!-- BETA PANEL (Collapsible) -->
  <div class="beta-panel">
    <div class="beta-header" onclick="toggleBetaPanel()">
      <span>üîß BETA: AI ACCESS METHODS <span class="blink">(ADVANCED)</span></span>
      <span id="betaToggle">‚ñº</span>
    </div>
    
    <div class="beta-content" id="betaContent">
      <p style="color: #aaa; margin-bottom: 20px;">
        These methods allow you to use your own AI access. The public front-end uses Method 1 by default.
      </p>
      
      <div class="beta-method">
        <h3>Method 1: Public Proxy (Default)</h3>
        <p>Uses free public AI endpoints. Limited but works.</p>
        <button class="beta-button" onclick="useMethod(1)">Use This Method</button>
        <span class="status-indicator status-online"></span>
      </div>
      
      <div class="beta-method">
        <h3>Method 2: Bookmarklet (Your Access)</h3>
        <p>Drag to bookmarks, uses your Claude/ChatGPT access.</p>
        <a href="javascript:(function(){
          const text = prompt('Text to translate:','Ancient wisdom awaits...');
          if(text) {
            window.open('https://claude.ai/new','_blank');
            alert('Open Claude and paste request.');
          }
        })();" class="beta-button">
          üìñ DRAG ME ‚Üí Bookmark Bar
        </a>
      </div>
      
      <div class="beta-method">
        <h3>Method 3: Direct AI Site</h3>
        <p>Open AI site with pre-filled prompt.</p>
        <button class="beta-button" onclick="openClaudeDirect()">Open Claude</button>
        <button class="beta-button" onclick="openChatGPTDirect()">Open ChatGPT</button>
      </div>
      
      <div class="beta-method">
        <h3>Method 4: Your API Key</h3>
        <p>Use your own API key (requires backend setup).</p>
        <input type="password" id="userApiKey" placeholder="sk-..." style="width: 200px; padding: 5px; background: #222; color: white;">
        <button class="beta-button" onclick="useOwnApiKey()">Connect</button>
      </div>
      
      <div style="margin-top: 20px; padding: 15px; background: #002222; border: 1px solid var(--cyber-blue);">
        <strong>Current Method:</strong> <span id="currentMethod">Public Proxy</span><br>
        <strong>Translations Today:</strong> <span id="translationCount">0</span>
      </div>
    </div>
  </div>

  <!-- BACKEND VIEW (Hidden) -->
  <div class="backend-view" id="backendView">
    <h3 style="color: var(--cyber-blue); margin-top: 0;">üîß TRANSLATION BACKEND DATA</h3>
    
    <div class="backend-section">
      <strong>SOURCE MATERIAL:</strong>
      <div id="sourceMaterial" class="code-block">
        Loading source data...
      </div>
    </div>
    
    <div class="backend-section">
      <strong>AI PROCESS LOG:</strong>
      <div id="processLog" class="code-block">
        > Initializing translation engine...<br>
        > Searching ancient text database...<br>
        > Preparing AI request...
      </div>
    </div>
    
    <div class="backend-section">
      <strong>FULL TRANSLATION DATA:</strong>
      <pre id="fullData">{"status": "pending"}</pre>
    </div>
    
    <div class="backend-section">
      <strong>PROOF OF WORK:</strong>
      <div class="code-block" id="proofOfWork">
        Timestamp: <span id="timestamp">--:--:--</span><br>
        AI Provider: <span id="aiProvider">Public Proxy</span><br>
        Hash: <span style="color: var(--matrix-green);">‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà</span>
      </div>
    </div>
    
    <div style="text-align: center; margin-top: 20px;">
      <button class="beta-button" onclick="toggleBackendView()">Close Backend</button>
      <button class="beta-button" onclick="downloadTranslationData()">Download Data</button>
    </div>
  </div>

  <!-- VISITOR COUNTER -->
  <div class="visitor-counter">
    <div style="font-size: 2em; color: var(--retro-pink);">‚éà ‚éà ‚éà</div>
    <div>WISDOM TRANSLATIONS GENERATED:</div>
    <div style="font-size: 2em; color: var(--matrix-green); font-family: monospace;">
      <span id="globalCounter">0000</span><span class="blink">‚ñà</span>
    </div>
    <div style="font-size: 0.8em; color: #666; margin-top: 10px;">
      Since 1999 ‚Ä¢ AI-Assisted Since 2024
    </div>
  </div>

  <!-- CONSTRUCTION -->
  <div class="construction">
    <span class="blink">‚ö†Ô∏è</span> UNDER CONSTRUCTION <span class="blink">‚ö†Ô∏è</span><br>
    <small>Magic in progress. Reality may fluctuate.</small>
  </div>

  <!-- FOOTER -->
  <div class="footer">
    <p>ìÅπ Ancient Wisdom Oracle ‚Ä¢ AI Translation Engine ìÇÄ</p>
    <p>This system uses multiple AI methods to translate forgotten texts.<br>
       No single API key required. User-powered when needed.</p>
    <p style="margin-top: 20px;">
      <img src="https://web.archive.org/web/20091027041310/http://geocities.com/area51/zone/1927/counter.gif" height="30">
      <img src="https://web.archive.org/web/20090829083051/http://geocities.com/SiliconValley/Vista/1296/under_con.gif" height="31">
    </p>
  </div>
</div>

<script>
// ===== GLOBAL STATE =====
let currentTranslation = null;
let translationCount = parseInt(localStorage.getItem('translationCount')) || 0;
let currentMethod = 'public_proxy';

// Ancient texts database
const ANCIENT_TEXTS = [
  {
    id: 'etruscan_linen',
    name: 'Etruscan Linen Book',
    text: 'cea sren tva hel rasce clenar',
    language: 'Etruscan',
    era: '3rd century BCE',
    location: 'Zagreb, Croatia',
    description: 'Linen wrappings from a mummy, longest Etruscan text.',
    subject: 'Funerary rites'
  },
  {
    id: 'linear_a',
    name: 'Linear A Tablet HT 13',
    text: 'a-ta-i-*301-wa-ja / ko-no-so / pa-i-to',
    language: 'Linear A',
    era: '1800-1450 BCE',
    location: 'Crete, Greece',
    description: 'Minoan administrative tablet, undeciphered script.',
    subject: 'Ancient economics'
  },
  {
    id: 'babylonian_stars',
    name: 'Babylonian Astronomical Diary',
    text: 'MUL.APIN ·π£i-it MUL.MUL ina AN-e',
    language: 'Akkadian Cuneiform',
    era: '7th century BCE',
    location: 'Mesopotamia',
    description: 'Star observations for calendar keeping.',
    subject: 'Ancient astronomy'
  },
  {
    id: 'rongorongo',
    name: 'Rongorongo Tablet',
    text: 'Bird-man glyph ‚Ä¢ Crescent ‚Ä¢ Fish hook',
    language: 'Rongorongo',
    era: 'Unknown',
    location: 'Easter Island',
    description: 'Wooden tablet with undeciphered glyphs.',
    subject: 'Polynesian knowledge'
  }
];

// ===== PUBLIC FRONT-END MAGIC =====
async function initiateTranslation() {
  // Reset display
  document.getElementById('wisdomResult').classList.add('hidden');
  document.getElementById('translationDisplay').innerHTML = `
    <div style="text-align: center; padding: 40px 20px;">
      <div class="status-indicator status-processing" style="width: 20px; height: 20px; margin: 0 auto 20px auto;"></div>
      <div style="color: var(--amber); font-size: 1.2em;">Accessing Ancient Text Database...</div>
      <div style="color: #666; margin-top: 20px; font-family: monospace;">
        > Scanning archive...<br>
        > Selecting untranslated text...<br>
        > Preparing AI translation...
      </div>
    </div>
  `;
  
  document.getElementById('aiStatus').textContent = 'Processing...';
  
  // Select random text
  const textData = ANCIENT_TEXTS[Math.floor(Math.random() * ANCIENT_TEXTS.length)];
  currentTranslation = textData;
  
  // Update backend view immediately
  updateBackendView('selecting', textData);
  
  // Simulate processing delay
  await new Promise(resolve => setTimeout(resolve, 2000));
  
  // Process with current method
  let result;
  try {
    result = await processWithCurrentMethod(textData);
  } catch (error) {
    result = await getFallbackTranslation(textData);
  }
  
  // Update counters
  translationCount++;
  localStorage.setItem('translationCount', translationCount);
  updateCounters();
  
  // Display result
  displayTranslationResult(textData, result);
  
  // Update backend with full data
  updateBackendView('complete', textData, result);
}

async function processWithCurrentMethod(textData) {
  switch(currentMethod) {
    case 'public_proxy':
      return await usePublicProxy(textData);
    case 'user_api':
      return await useUserApi(textData);
    default:
      return await getSimulatedTranslation(textData);
  }
}

// ===== REAL AI PROMPT TEMPLATE =====
function generateAIPrompt(textData) {
  return `You are an expert historical linguist and wisdom extractor.

TASK: Translate this ancient text and extract profound wisdom.

SOURCE TEXT: "${textData.text}"
LANGUAGE: ${textData.language}
ERA: ${textData.era}
SUBJECT: ${textData.subject}
CONTEXT: ${textData.description}

Please provide:
1. A modern English translation (2-3 sentences)
2. One wisdom quip extracted from it (1-2 sentences, profound)
3. Brief historical/scientific context

Format as JSON:
{
  "translation": "your translation here",
  "quip": "wisdom quip here",
  "context_notes": "historical/scientific notes here"
}`;
}

async function usePublicProxy(textData) {
  // Try free public endpoint with our new prompt template
  try {
    const prompt = generateAIPrompt(textData);
    
    const response = await fetch('https://api.openai-proxy.org/v1/chat/completions', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        model: 'gpt-3.5-turbo',
        messages: [{
          role: 'user',
          content: prompt
        }],
        max_tokens: 300
      })
    });
    
    if (response.ok) {
      const data = await response.json();
      const aiText = data.choices[0].message.content;
      
      // Try to parse as JSON
      try {
        const parsed = JSON.parse(aiText);
        return {
          quip: parsed.quip || aiText,
          fullTranslation: parsed.translation || aiText,
          context: parsed.context_notes || '',
          method: 'Public Proxy (GPT-3.5)',
          success: true,
          rawResponse: aiText
        };
      } catch (e) {
        // If not JSON, use as-is
        return {
          quip: extractWisdomFromText(aiText),
          fullTranslation: aiText,
          context: 'AI responded with free text',
          method: 'Public Proxy (GPT-3.5)',
          success: true,
          rawResponse: aiText
        };
      }
    }
  } catch (error) {
    console.log('Public proxy failed:', error);
  }
  
  // Fallback to simulated
  return await getSimulatedTranslation(textData);
}

// Helper to extract wisdom from free-text AI responses
function extractWisdomFromText(text) {
  // Look for quotes or short profound statements
  const lines = text.split('\n').filter(line => line.trim().length > 0);
  
  // Try to find a wisdom-like line (short, profound, maybe in quotes)
  for (const line of lines) {
    const trimmed = line.trim();
    // Look for quotes
    if ((trimmed.includes('"') && trimmed.length < 150) || 
        (trimmed.length > 20 && trimmed.length < 120 && 
         (trimmed.includes('wisdom') || trimmed.includes('teach') || 
          trimmed.includes('learn') || trimmed.endsWith('.')))) {
      return trimmed.replace(/"/g, '').replace(/^['"]|['"]$/g, '');
    }
  }
  
  // Fallback: first shortish line
  for (const line of lines) {
    if (line.length > 30 && line.length < 100) {
      return line.trim();
    }
  }
  
  // Ultimate fallback
  return "Ancient wisdom: The deepest truths often hide in plain sight.";
}

async function getSimulatedTranslation(textData) {
  // Simulated AI responses
  const responses = {
    'etruscan_linen': {
      quip: "The Etruscans knew: What makes water holy isn't the blessing, but the vessel's willingness to hold it.",
      translation: "This linen text describes ritual purification ceremonies. The words suggest concepts of cleanliness and ceremonial vessels used in funerary rites.",
      context_notes: "Etruscan burial practices emphasized purification rituals for the soul's journey to the afterlife."
    },
    'linear_a': {
      quip: "Minoan wisdom: The first written words were receipts‚Äîcivilization began when we agreed what things were worth.",
      translation: "Administrative record mentioning locations (Knossos, Phaistos) and quantities of stored goods or trade items.",
      context_notes: "Linear A remains undeciphered, but likely records Minoan economic transactions from the Bronze Age."
    },
    'babylonian_stars': {
      quip: "Babylonian astronomers observed: Time is the universe's way of making sure everything doesn't happen at once.",
      translation: "Records the position of the Pleiades star cluster, used for agricultural and religious calendar keeping.",
      context_notes: "Babylonian astronomy was advanced for its time, with detailed records dating back to 7th century BCE."
    },
    'rongorongo': {
      quip: "Rapa Nui insight: A society that forgets how to read its own history is already carving its obituary in stone.",
      translation: "The glyphs likely record genealogical information or astronomical knowledge important to Easter Island's civilization.",
      context_notes: "Rongorongo is an undeciphered script unique to Easter Island, with only 25 surviving wooden tablets."
    }
  };
  
  const response = responses[textData.id] || {
    quip: "Ancient wisdom: Some mysteries aren't meant to be solved, only contemplated.",
    translation: "This text contains cultural knowledge that has been lost to time. Translation remains partial.",
    context_notes: "Many ancient scripts remain undeciphered, preserving their mysteries for future generations."
  };
  
  return {
    ...response,
    method: 'Simulated AI',
    success: true,
    rawResponse: JSON.stringify(response)
  };
}

async function getFallbackTranslation(textData) {
  // Ultimate fallback
  const wisdoms = [
    "The river teaches without words: persistence shapes stone.",
    "Ancient trees remember: growth requires both reaching up and rooting down.",
    "Star navigation wisdom: Sometimes you find your way by what you cannot see."
  ];
  
  return {
    quip: wisdoms[Math.floor(Math.random() * wisdoms.length)],
    translation: `The ${textData.language} text "${textData.text}" from ${textData.era} contains wisdom about ${textData.subject}.`,
    context: 'Translation unavailable - using fallback wisdom generator.',
    method: 'Fallback Generator',
    success: true,
    rawResponse: 'Fallback activated'
  };
}

function displayTranslationResult(textData, result) {
  document.getElementById('translationDisplay').innerHTML = `
    <div style="padding: 20px;">
      <div style="color: var(--cyber-blue); margin-bottom: 15px;">
        <strong>ìÅπ ${textData.name.toUpperCase()} ìÇÄ</strong><br>
        <small>${textData.language} ‚Ä¢ ${textData.era} ‚Ä¢ ${textData.location}</small>
      </div>
      <div class="code-block" style="margin: 15px 0;">
        ${textData.text}
      </div>
      <div style="color: #888; font-size: 0.9em; margin: 10px 0;">
        Subject: ${textData.subject} ‚Ä¢ ${textData.description}
      </div>
    </div>
  `;
  
  document.getElementById('wisdomText').innerHTML = 
    `${result.quip}<br><small style="color: #666; font-size: 0.7em;">${result.context || ''}</small>`;
  document.getElementById('wisdomResult').classList.remove('hidden');
  document.getElementById('aiStatus').textContent = 'Ready';
}

// ===== BETA PANEL FUNCTIONS =====
function toggleBetaPanel() {
  const content = document.getElementById('betaContent');
  const toggle = document.getElementById('betaToggle');
  
  if (content.style.display === 'block') {
    content.style.display = 'none';
    toggle.textContent = '‚ñº';
  } else {
    content.style.display = 'block';
    toggle.textContent = '‚ñ≤';
  }
}

function useMethod(methodNum) {
  const methods = ['public_proxy', 'bookmarklet', 'direct_ai', 'user_api'];
  currentMethod = methods[methodNum - 1];
  
  const methodNames = ['Public Proxy', 'Bookmarklet', 'Direct AI Site', 'Your API Key'];
  document.getElementById('currentMethod').textContent = methodNames[methodNum - 1];
  
  // Visual feedback
  document.getElementById('aiStatus').innerHTML = 
    `<span style="color: var(--matrix-green);">Method ${methodNum} Active</span>`;
  
  alert(`Switched to ${methodNames[methodNum - 1]}. Next translation will use this method.`);
}

function openClaudeDirect() {
  const prompt = encodeURIComponent('Translate ancient text and extract wisdom.');
  window.open(`https://claude.ai/new`, '_blank');
  
  // Store prompt for user to copy
  setTimeout(() => {
    alert('Open Claude and paste: "Translate ancient text and extract wisdom."');
  }, 500);
}

function openChatGPTDirect() {
  window.open('https://chat.openai.com/', '_blank');
  setTimeout(() => {
    alert('Ask ChatGPT: "Translate ancient text and extract wisdom."');
  }, 500);
}

function useOwnApiKey() {
  const key = document.getElementById('userApiKey').value;
  if (!key) {
    alert('Please enter an API key first.');
    return;
  }
  
  // In reality, this would be sent to a backend
  alert(`API key received (first chars: ${key.substring(0,6)}...).\n\nFor security, this would connect to a backend server.`);
  currentMethod = 'user_api';
  document.getElementById('currentMethod').textContent = 'Your API Key';
}

// ===== AI COLLABORATION LOGGING =====
function logAIContribution(aiId, changeType, description, filesAffected) {
  const timestamp = new Date().toISOString().split('T')[0]; // YYYY-MM-DD
  const entry = `[${aiId}] | ${timestamp} | ${changeType} | ${description} | ${filesAffected}`;
  
  // For now, log to console and backend display
  console.log(`üìù AI Contribution: ${entry}`);
  
  // Also add to backend process log for transparency
  const processLog = document.getElementById('processLog');
  if (processLog) {
    processLog.innerHTML += `\n> üìù AI_LOG: ${aiId} - ${description}`;
    processLog.scrollTop = processLog.scrollHeight;
  }
  
  // In Phase 2: This would send to backend to update UPDATE.log file
  // fetch('/api/log-contribution', { method: 'POST', body: JSON.stringify({ entry }) });
  
  return entry;
}

// Initialize logging for current session
logAIContribution('CLAUDE-3', 'ENHANCEMENT', 'Added AI collaboration logging system', 'index.html');
  
// ===== BACKEND VIEW FUNCTIONS =====
function toggleBackendView() {
  const backend = document.getElementById('backendView');
  if (backend.style.display === 'block') {
    backend.style.display = 'none';
  } else {
    backend.style.display = 'block';
    backend.scrollIntoView({ behavior: 'smooth' });
  }
}

function updateBackendView(stage, textData, result) {
  // Update source material with potential link
  const sourceWithLink = {
    ...textData,
    // Add placeholder for AI-provided source
    ai_provided_source: "(AI will provide source link here in future)"
  };
  document.getElementById('sourceMaterial').textContent = JSON.stringify(sourceWithLink, null, 2);
  
  // Update process log
  const now = new Date().toLocaleTimeString();
  let log = document.getElementById('processLog').innerHTML;
  
  switch(stage) {
    case 'selecting':
      log += `\n> Selected: ${textData.name}`;
      log += `\n> Text: "${textData.text.substring(0, 30)}..."`;
      log += `\n> Time: ${now}`;
      break;
    case 'complete':
      log += `\n> Translation complete!`;
      log += `\n> Method: ${result.method}`;
      log += `\n> Success: ${result.success}`;
      log += `\n> Completed: ${now}`;
      
      // Update full data
      const fullData = {
        source: textData,
        translation: result,
        timestamp: new Date().toISOString(),
        method: currentMethod
      };
      document.getElementById('fullData').textContent = JSON.stringify(fullData, null, 2);
      
      // Update proof of work
      document.getElementById('timestamp').textContent = now;
      document.getElementById('aiProvider').textContent = result.method;
      document.getElementById('proofOfWork').innerHTML = 
        `Timestamp: ${now}<br>AI Provider: ${result.method}<br>Hash: ${generateRandomHash()}`;
      break;
  }
  
  document.getElementById('processLog').innerHTML = log;
  document.getElementById('processLog').scrollTop = document.getElementById('processLog').scrollHeight;
}

function generateRandomHash() {
  const chars = '0123456789abcdef';
  let hash = '';
  for (let i = 0; i < 16; i++) {
    hash += chars[Math.floor(Math.random() * chars.length)];
  }
  return hash;
}

function downloadTranslationData() {
  if (!currentTranslation) {
    alert('No translation data available.');
    return;
  }
  
  const data = {
    source: currentTranslation,
    timestamp: new Date().toISOString(),
    method: currentMethod,
    count: translationCount
  };
  
  const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `ancient-translation-${Date.now()}.json`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

// ===== UTILITY FUNCTIONS =====
function updateCounters() {
  document.getElementById('translationCount').textContent = translationCount;
  document.getElementById('globalCounter').textContent = 
    translationCount.toString().padStart(4, '0');
}

function useUserApi(textData) {
  // This would connect to user's API via backend
  alert('User API method would connect to your backend server.');
  return getSimulatedTranslation(textData);
}

// ===== INITIALIZATION =====
document.addEventListener('DOMContentLoaded', function() {
  updateCounters();
  
  // Make blink work
  const blinkElements = document.querySelectorAll('.blink');
  blinkElements.forEach(el => {
    setInterval(() => {
      el.style.visibility = el.style.visibility === 'hidden' ? 'visible' : 'hidden';
    }, 500);
  });
  
  // Initial backend view update
  document.getElementById('timestamp').textContent = new Date().toLocaleTimeString();
  
  console.log('ìÅπ Ancient Wisdom Oracle initialized ìÇÄ');
});
 
// Query feature toggle
document.getElementById('queryToggle').onclick = function() {
  const inputDiv = document.getElementById('queryInput');
  inputDiv.style.display = (inputDiv.style.display === 'none' || inputDiv.style.display === '') ? 'block' : 'none';
};

// Temporary test for query button
function initiateQueryTranslation() {
  const query = document.getElementById('userQuery').value.trim();
  alert('Query received: ' + (query || 'none') + '\nFeature coming soon!');
}
</script>

</body>
</html>
